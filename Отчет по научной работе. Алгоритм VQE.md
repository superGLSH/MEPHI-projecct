**VQE (Variational Quantum Eigensolver)** - перспективный и достаточно удобный алгоритм для работы с многомерной оптимизацией, который использует принципы квантовой механики для ускорения и улучшения решения оптимизационных задач.
#### Введение
###### Анзац

Квантовая цепь, генерирующая некоторое состояние с помощью параметризованных вентилей поворота и одного вида запутывающих гейтов называется анзац:

![[Ansatz.png|center|500]]

Для генерации различных состояний нужно подобрать нужные гейты вращения:

![[XYZrotates.png|center|500]]

Видно, что так как наблюдения ведутся в Z-базисе, то вращения на сфере Блоха вокруг него не ведут к каким-то интересующим изменениям, поэтому парой вращающих вентилей выбирают - $R_{x}(\theta)$ и $R_{y}(\phi)$, а запутывающим гейтом обычно выбирается тот, который легче всего реализовать на практике, например, iSWAP.

Важнейшая характеристика анзаца - его глубина. 
Состояние из $n$ кубит представляет из себя $2^{n}$ чисел в гильбертовом пространстве, а поэтому, для получения всех состояний представимых в гильбертовом пространстве размерности $2^{n}$, нужно такое же количество параметризованных гейтов. Тогда имеет место следующая формула:$$D = \frac{2^{n-1}}{n}$$где $D$ - глубина цепи, $n$ - количество кубит.
###### Ground-State системы

В квантовой механике вводится определение средней величины:
$$\langle A \rangle =\bra{\psi}\widehat{A}\ket{\psi}$$
В таком случае можно ввести понятие **Ground-State**. 
**Ground-State** системы - это такое состояние $\ket{\psi}$ при котором среднее значение оператора энергии (гамильтониана) минимально, т.е. : 
$$E \le \bra{\psi}\widehat{H}\ket{\psi}$$
Так как для большинства физических систем справедливо, что они находятся в состоянии с минимальной энергией, то определение этого состояния является наиболее интересующей задачей, связанной с физической системой.
###### Квантовые измерения

В квантовых алгоритмах обычно проводятся вычисления в Z-базисе:

![[BlochSphere.png |center|300]]
В таком случае $\ket{0}$ и $\ket{1}$ - собственные вектора оператора $\widehat{Z} = \begin{pmatrix}1 & 0 \\0 &-1\end{pmatrix}$. Тогда:$$\begin{flalign}
&\ket{0}=\begin{pmatrix}1\\0\end{pmatrix}, \space \lambda = 1 \\
&\ket{1}=\begin{pmatrix}0\\1\end{pmatrix},\space \lambda = -1 \\
\end{flalign}$$
Тогда оператор $\widehat{Z}$ можно записать в дираковских обозначениях: $\widehat{Z}=\ket{0}\bra{0}-\ket{1}\bra{1}$
Как будет показано далее - в контексте VQE, наиболее интересные измерения - это измерения операторов $\widehat{Z_i}$, $\widehat{Z_i}\otimes\widehat{Z_j}$. Покажем, как происходят подобные измерения:

$\bullet\quad\langle\widehat{Z}\rangle=\bra{\psi}\widehat{Z}\ket{\psi}=(c_0^*\bra{0}+c_1^*\bra{1})\times(\ket{0}\bra{0}-\ket{1}\bra{1})\times(c_0\ket{0}+c_1\ket{1})=\left|c_0\right|^2-\left|c_1\right|^2$

$\bullet\quad \widehat{Z}_1\otimes\widehat{Z}_2=(\ket{0}\bra{0}-\ket{1}\bra{1})_1\otimes(\ket{0}\bra{0}-\ket{1}\bra{1})_2=\ket{00}\bra{00}-\ket{01}\bra{01}-\ket{10}\bra{10}+\ket{11}\bra{11}$

$\begin{aligned}\bullet\quad&\langle\widehat{Z}_1\otimes\widehat{Z}_2\rangle= \bra{\psi}\widehat{Z}_1\otimes\widehat{Z}_2\ket{\psi}=(c_{00}^*\bra{00}+c_{01}^*\bra{01}+c_{10}^*\bra{10}+c_{11}^*\bra{11})\times\\&\times(\ket{00}\bra{00}-\ket{01}\bra{01}-\ket{10}\bra{10}+\ket{11}\bra{11})\times(c_{00}\ket{00}+c_{01}\ket{01}+c_{10}\ket{10}+c_{11}\ket{11})=\\&=\left|c_{00}\right|^2-\left|c_{01}\right|^2- \left|c_{10}\right|^2+\left|c_{11}\right|^2\end{aligned}$

В целом, если нужно проводить измерения какого-то оператора, который представляет из себя несколько операторов $\widehat{Z}$, которые действуют на какое-то количество кубитов, то формула для получения среднего значения нужного нам оператора выводится по аналогии аккуратным тензорным перемножением.
Иногда, оказывается полезным измерение операторов $\widehat{X}$, $\widehat{Y}$. Их измерение в Z-базисе невозможно, поэтому нужно перевести их в Z-базис с помощью следующих преобразований:

$\bullet \quad \widehat{X}=\widehat{H}\widehat{Z}\widehat{H}\quad\Rightarrow\quad\langle\widehat{X}\rangle=\bra{\psi}\widehat{X}\ket{\psi}=\bra{\psi}\widehat{H}\widehat{Z}\widehat{H}\ket{\psi}=\bra{\psi'}\widehat{Z}\ket{\psi'}$, где $\ket{\psi'}=\widehat{H}\ket{\psi}$

$\bullet \quad \widehat{Y}=\widehat{S}\widehat{H}\widehat{Y}\widehat{H}\widehat{S}^\dagger\quad\Rightarrow\quad\langle\widehat{Y}\rangle=\bra{\psi}\widehat{Y}\ket{\psi}=\bra{\psi}\widehat{S}\widehat{H}\widehat{Y}\widehat{H}\widehat{S}^\dagger\ket{\psi}=\bra{\psi''}\widehat{Z}\ket{\psi''}$, где $\ket{\psi''}=\widehat{H}\widehat{S}^\dagger\ket{\psi}$

В целом же, некоторое тензорное произведение операторов Паули, действующих на разные кубиты, называется *строкой Паули*.
###### Модель Изинга

Модель Изинга - математическая модель, описывающая механизм намагниченности, которая выглядит следующим образом:
$$H = -J\sum_{i=1}^{n-1}\sigma_z^i\sigma_z^{i+1}-h_z\sum_{i=1}^n\sigma_z^i$$
Здесь первая сумма представляет из себя взаимодействие между соседними атомами, а вторая - действие поперечного магнитного поля на атомы. $\sigma_z^i$ в данном случае принимает значение -1 (поле вниз) или 1 (поле вверх). Решением данной модели является список из значений $\sigma_z^1$, $\sigma_z^2$, ... ,$\sigma_z^n$, такой чтобы $H$ принимало минимальное значение, которое соответствует реальному распределению спинов в цепочке атомов при действии на них заданного магнитного поля.

Данной модели Изинга соответствует гамильтониан:$$\widehat{H} = -J\sum_{i=1}^{n-1}\widehat{\sigma}_z^i\widehat{\sigma}_z^{i+1}-h_z\sum_{i=1}^n\widehat{\sigma}^i_z$$Такой гамильтониан можно записать в матричном виде, в котором он будет выглядеть как диагональная матрица ($\widehat{\sigma}_z$ представляется в виде диагональной матрицы, а действие на атом номером k в таком случае представляется в виде $\widehat{I}_1\otimes{}\widehat{I}_2\otimes{}\ldots\otimes{}\widehat{I}_{k-1}\otimes{}\widehat{\sigma}_z\otimes{}\widehat{I}_{k+1}\otimes{}\ldots\otimes{}\widehat{I}_n$, где $\widehat{I}_i$ - единичный оператор на позиции $i$, следовательно тензорное произведение будет выражаться диагональной матрицей, а сумма таких тензорных произведений - тоже будет выражаться диагональной матрицей).

В таком случае спектр гамильтониана - все числа на диагонали, а минимальное из этих чисел - минимальная энергия данной системы. Тогда Ground-State данной системы в векторном виде - вектор длиной $2^n$, состоящий из $2^n-1$ нулей и $1$ единицы.

Такой вектор представим в виде тензорного произведения из $n$ штук $\ket{0}$ и $\ket{1}$, соответственно получается, что таким образом была получена волновая функция для $n$ атомов, которая и является Ground-State данной системы.

Таким образом получается соответствие между моделью Изинга в операторном виде и классической моделью Изинга. Решение каждой - список из состояний атомов, в первом случае состоящий из элементов $\ket{0}$ и $\ket{1}$, а во втором - из -1 и 1.

В модель Изинга также можно ввести продольное магнитное поле, его действие на атомы задается следующей суммой (в операторном виде): $h_x\sum_{i=1}^n\widehat{\sigma}_x^i$

В данном случае однако, решение классической модели Изинга не будет выражаться таким простым образом. Так как $\widehat{\sigma}_x$ представима в виде недиагональной матрицы, то и сам гамильтониан будет представим в виде недиагональной матрицы, а следовательно - ее Ground-State это суперпозиция из нескольких состояний. 

-1 и 1 в классической модели, вообще говоря, выражают собой среднее значение $\widehat{\sigma}_z$ в двух крайних состояниях - состоянии вверх и вниз, что соответствует $\ket{\psi} =\ket{0}$ и $\ket{\psi} =\ket{1}$. В случае если $\ket{\psi}$ - некоторое запутанное состояние, то согласно формулам из раздела выше, среднее значение $\langle\widehat{\sigma}_z\rangle\in[-1,1]$. 

Итак, если внешнее магнитное поле - чисто поперечное, то решение классической модели Изинга полностью бинаризованное, но если есть некоторая поперечная составляющая, то решение будет списком из действительных чисел, иначе говоря чисто поперечное поле дает  дискретное решение, а поле с продольной составляющей - непрерывное. 

В целом, можно еще более обобщить модель Изинга:
$$H = -\sum_{i\ne{j}}J_{ij}\sigma_z^i\sigma_z^{j}-\sum_ih_z^i\sigma_z^i-\sum_ih_x^i\sigma_x^i$$
Такая модель учитывает и поперечное, и продольное магнитные поля, при этом значение их действия на каждый атом может быть различным. То же самое актуально и для пар атомов, которые могут взаимодействовать с уникальными коэффициентами для каждой пары.

Чем же интересна модель Изинга?

Модель Изинга - это прежде всего модель о поведении квантовых частиц в некоторых условиях (атомы в магнитном поле). Классическая модель Изинга применяется в расчетах некоторых числовых материалов для описания их поведения в магнитном поле. При этом размерность задачи растет очень быстро (системе из $n$ частиц в поперечном магнитном поле соответствует $2^n$ состояний системы), поэтому для решения данной модели применяются приближенные методы решения, например, метод Метрополиса. Иначе говоря, модель Изинга позволяет определить макрохарактеристики микросистемы (в терминологии статистической физики).

Однако приближенные методы не дают точного решения, а также макрохарактеристики не могут описать некоторые феномены, для которых нужно уже микроописание системы.

В таком случае реализуют другой подход - систему стараются описать с помощью другой контролируемой системы. В данном случае из-за масштаба рассматриваемых явлений сама система - квантовая (цепочка атомов), а соответственно и подход к ее описанию должен быть квантовый. Таким образом, получается, что классическая модель Изинга и проблемы описания микрохарактеристик с ней связанных, фактически, подводят к использованию квантовых компьютеров и квантовых алгоритмов. 

Однако, если модель Изинга была бы нужна для лишь одной достаточно узкой задачи, которую можно каким-то образом посчитать на квантовом компьютере, то разговоров о ней было бы куда меньше. Оказывается, достаточно широкий класс задач из области многомерной оптимизации можно свести к модели Изинга, то есть с помощью данной модели можно решать изначально не квантовые задачи квантовым подходом.

###### QUBO-задачи

QUBO (Квадратичная неограниченная двоичная оптимизация) - это такой класс задач, в которых целевая функция задана следующим выражением:
$$f_q(x) = x^TQx = \sum_{i=1}^n\sum_{j=1}^nQ_{ij}x_ix_j, \quad x_i\in[0, 1]$$
Решением такой задачи является вектор $\overrightarrow{x}=[x_1, x_2, \ldots, x_n]$, который обычно либо минимизируется, либо максимизируется.

Данная сумма, вообще говоря, распадается на две суммы, одна из которых содержит только перекрестные члены $x_ix_j$, а вторая - квадраты переменных $x_i^2$, но так как $x_i\in[0, 1]$, то $x_i^2=x_i$, то, соответственно, целевую функцию можно записать следующим образом:
$$f_q(x) = \sum_{i\ne{j}}Q_{ij}x_ix_j + \sum_{i}Q_{ii}x_i$$
Получается, что целевая функция содержит в себе как квадратичный член, так и линейный.

QUBO-задачи - это очень общий вид задач, поэтому к ним могут быть сведены многие задачи классического машинного обучения (регрессии, метод опорных векторов, кластеризация), однако более интересно найти практическое приложение задач QUBO. Для этого стоит обозначить следующий момент - ограничения по задаче в исходной форме вводятся только лишь весами перед соответствующими переменными. На практике же, на полученное решение часто накладываются внешние линейные ограничения вида равенств или неравенств, поэтому необходимо отметить как задать их в QUBO-модели:

- Ограничения вида  $\sum_{i=1}^na_ix_i = b$
	Первым делом, нужно проверить, имеет ли заданное ограничение решение любым из доступных методов, например: $\parallel{\sum_{i=1}^na_ix_i - b}\parallel^2 \longrightarrow min$. В данном случае, если минимизация дает любой, отличный от нуля ответ, то задачу с таким ограничением невозможно решить.
	Если решение существует, тогда к исходной целевой функции нужно добавить следующий член: $$(\sum_{i=1}^na_ix_i - b)^2$$

- Ограничение вида $\sum_{i=1}^na_ix_i \le b$
	Данное ограничение вводится следующим образом: вводится некоторая целочисленная переменная $Z$, тогда ограничение вводится в модель добавлением следующего члена: $$P(\sum_{i=1}^na_ix_i+Z - b)^2$$
	Здесь P - некоторый штрафной коэффициент, который выбирается для задачи.

- Ограничение вида $\sum_{i=1}^na_ix_i \ge b$
	Сводится к ограничению выше, домножением коэффициентов $a_i$ на $-1$.

Также стоит отметить, что QUBO работает не только с бинарными переменными, но для этого их надо бинаризировать:

- Целые переменные: $x_i=l_i+f(u_i -l_i)$, где $f(b)=\sum_1^{[\log_2{b+1]}}2^{i-1}y_i$, где $x_i\in[l_i,u_i]$, $y_i\in[0,1]$
- Дискретные переменные: $x_i=\sum_1^ma_iy_i$, где $x_i\in[a_1, a_2, \ldots, a_m]$, $y_i\in[0,1]$.
- Непрерывный случай: выбираем точность и переходим к дискретному случаю.

Последнее, что стоит отметить - взаимосвязь модели Изинга и QUBO-модели. Данные модели очень похожи друг на друга, но в них отличаются сами переменные с которыми они работают, которые связаны следующим соотношением:
$$x_i=\frac{1+\sigma_i}{2}, \quad x_i\in[0,1], \quad \sigma_i \in[-1,1]$$
Таким образом все то множество задач, которое может быть решено QUBO-подходом, может быть переведено в модель Изинга, а соответственно может быть решено на квантовом оборудовании.
###### QUBO-формулировка и модель Изинга на примере задачи рюкзака

Классическая формулировка задачи: имеется $n$ предметов. Для них имеется:
- $\overrightarrow{w}=[w_1, w_2, \ldots, w_n]$ - список с весом каждого груза
- $\overrightarrow{v}=[v_1, v_2, \ldots, v_n]$ - список с количественной ценностью каждого груза
- $W_{max}$ - максимально допустимый вес
Нужно собрать рюкзак так, чтобы он имел максимальную ценность.

Для QUBO формулировки воспользуемся правилами, обозначенными выше.
У нас есть линейное ограничение вида $\sum_{i=1}^nw_ix_i\le W_{max}$, соответственно, целевая функция выглядит следующим образом:$$QUBO = P\left(W_{max} - \sum_1^nw_ix_i-Z\right)^2-\sum_1^nv_ix_i$$
$P$ выбирается таким образом, штраф был точно больше второй суммы. Для этой задачи можно выбрать $P=max(w_i)+1$. 

$Z$ же является целой переменной и в соответствии с правилами выше: $0\le m \le W_{max}$. В таком случае $Z=\sum_1^{[\log_2{b+1]}}2^{i-1}y_i$, а значит модель будет выглядеть следующим образом: $$QUBO = P\left(W_{max} - \sum_1^nw_ix_i-\sum_1^{[\log_2{b+1]}}2^{i-1}y_i\right)^2-\sum_1^nv_ix_i$$Раскрывая скобки и избавляясь от констант, получим:
$$\begin{aligned}
&QUBO = 2P\left(\sum_{i\ne{j}}w_iw_jx_ix_j+\sum_{i\ne{j}}2^{i+j-2}y_iy_j+\sum_{i,j}2^{j-1}w_ix_iy_j\right) -\sum_iv_ix_i -\\
&-2PW_{max}\left(\sum_iw_ix_i+\sum_i2^{i-1}y_i\right) +P\left(\sum_iw_i^2x_i+\sum_i2^{2i-2}y_i\right)

\end{aligned}$$
Модель Изинга же получается подстановкой $x_i=\frac{1+\sigma_i}{2}$ в QUBO модель:$$H = P\left(W_{max} - \sum_1^nw_i \frac{1+\sigma_i}{2}-\sum_1^{[\log_2{b+1]}}2^{i-1} \frac{1+t_i}{2}\right)^2-\sum_1^nv_i \frac{1+\sigma_i}{2}$$
После раскрытия скобок и избавления от констант, получим:
$$\begin{aligned}
&H = \frac{P}{2}\left(\sum_{i\ne{j}}w_iw_j\sigma_i\sigma_j+\sum_{i\ne{j}}2^{i+j-2}t_it_j+\sum_{i,j}2^{j-1}w_i\sigma_it_j\right) -\frac{1}{2}\sum_iv_i\sigma_i -\\
&-PL\left(\sum_iw_i\sigma_i+\sum_i2^{i-1}t_i\right), 
\quad L=W_{max} - \frac{1}{2}\left(\sum_iw_i+\sum_i2^{i-1}\right)

\end{aligned}$$
Таким образом, были получены QUBO-формулировка и формулировка в виде модели Изинга для задачи рюкзака в явном и в неявном виде.
###### VQE

Алгоритм VQE, как было сказано во введении, предназначен для многомерной оптимизации. Не смотря на то, что он считается квантовым алгоритмом - по сути как-то связанным с квантовыми алгоритмами оказывается лишь один шаг. 

Блок схема алгоритма приведена ниже:

![[Pasted image 20241222124700.png|center|500]]

Перерасчет параметров ведется с помощью классических оптимизаторов, и выбор нужного является достаточно важной задачей, так как оптимизатор должен сочетать в себе как высокую точность попадания в минимум (желательно глобальный, но вообще говоря VQE не гарантирует попадание в глобальный минимум), так и хорошую работу с большим количеством параметров, с которыми так или иначе придется работать, а также, если речь идет о вычислениях на настоящем квантовом компьютере, оптимизация должна быть устойчива к шумам.

Все вышеперечисленное в сухом остатке дает понять, что выбор хорошего оптимизатора - одна из ключевых задач в реализации VQE для какой-то конкретной задачи.
#### Практическая реализация алгоритма VQE

В качестве платформы для реализации VQE было выбрано решение от Google - Cirq. Выбор обусловлен тем, что Cirq обладает удобным синтаксисом, а также тесной интеграцией с некоторыми другими библиотеками, как, например, Tensorflow и ее подмодулем Tensorflow Quantum, которые, будучи одними из самых передовых решений в сфере машинного обучения, в дальнейшем могут использоваться для решения более сложных задач квантового машинного обучения.

Перед реализацией достаточно сложного VQE были реализованы другие, более простые алгоритмы, для того, чтобы наработать навык работы с Cirq. Были реализованы следующие алгоритмы:

- Алгоритм квантовой телепортации
- Алгоритмы, связанные с классическими вычислениями - модуль классической арифметики, а также модули, показывающие возможность практической реализации логических операций (конъюнкция, дизъюнкция, импликация) 
- Алгоритм Дойча
- Алгоритм квантовой отдачи (Phase-Kick)
- Квантовое преобразование Фурье
- Алгоритм квантовой оценки фазы

После реализации данных алгоритмов, в целом, были наработаны базовые навыки работы с Cirq, а также произошло знакомство с общепринятыми практиками работы с данной библиотекой, поэтому дальше была возможность реализовывать более сложные алгоритмы.

Перед рассказом о работе непосредственно с VQE, стоит отметить следующее - моделирование некоторого квантового алгоритма на Cirq происходит следующим образом:

- Инициализация кубитов
- Подготовка цепи
- Симуляция

Последний пункт - симуляция, представляет особый интерес. В Cirq реализованы два подхода к симуляции - **run()** и **simulate()**. Первый дает как результат значения кубит при измерении, по сути моделируя реальные квантовые вычисления, со сбором нужной статистики, второй же на выходе дает финальное состояние системы в виде вектора, или строки в дираковских обозначениях, или в виде матрицы плотности.

Оба подхода применимы в разных случаях. В случае, если необходимо узнать, какое состояние получается на выходе системы более удобно использовать **run()**, так как в худшем случае для данной цепи нужно будет собрать некоторую статистику и найти наиболее вероятное состояние, в то время как определение вектора состояния системы не дает такой удобной возможности по причине того, что он либо представляет из себя вектор длины $2^n$, который необходимо вернуть в вид суперпозиции нескольких состояний, либо, в дираковских обозначениях, объект класса **String()**, который нужно также транслировать в численный вид, чтобы найти наиболее вероятное состояние.

В целом, подход через вектор состояния, конечно, дает более полную информацию о системе с информацией о всех ее возможных состояниях, но задача VQE - дать наиболее вероятное состояние данной системы, которое чаще всего одно, поэтому знание о всех возможных состояниях чаще всего избыточно.

Однако основная ниша **simulate()** в контексте VQE, заключается в другом, а именно, в использовании ее для непосредственной минимизации гамильтониана, так как статистический подход по определению будет давать зашумленный результат, который будет сложнее минимизировать.
###### Базовая реализация VQE

Базовая реализация VQE состоит из следующих модулей:

- Модуль создания/загрузки модели Изинга - векторов $J_x$, $J_z$, отвечающих за действие продольного и поперечного магнитного поля и матрицы $U_{zz}$, отвечающей за силу взаимодействия между кубитами.
- Модуль создания анзаца нужной глубины, зависящего от $2\times n \times d$ параметров, отвечающих за углы поворота в гейтах $R_x$ и $R_z$, где d - глубина анзаца.
- Модуль расчета гамильтониана на основе состояния, генерируемого анзацем
- Модуль минимизации гамильтониана
- Модуль вывода итогового состояния

```python title="Пример реализации"
import cirq  
import cirq.linalg  
import numpy as np  
from scipy.optimize import minimize  
from functools import partial  
import time  
  
  
def Anzatz(n, teta, depth, measurment_gates=False):  # создание анзаца
    qubits = cirq.LineQubit.range(n)  
    for i in range(depth):  
        yield [cirq.Rx(rads=teta[2 * i * n + j])(qubits[j]) for j in range(n)]  
        yield [cirq.Ry(rads=teta[(2 * i + 1) * n + j])(qubits[j]) for j in range(n)]  
        yield [cirq.CNOT(qubits[j], qubits[j + 1]) for j in range(n - 1)]  
    if measurment_gates:  
        yield [cirq.M(i) for i in qubits]  
  

# среднее значение гамильтониана рассчитанное с помощью run()
def find_mean_hamiltonian_run(n, teta, Uzz, Jz, depth, repetitions):  
    circuit = cirq.Circuit()  
    circuit.append(Anzatz(n, teta, depth, measurment_gates=True))  
    res = cirq.Simulator().run(circuit, repetitions=repetitions).data.to_numpy()  
  
    p = np.array([[(res[:, i] == 0).sum(), (res[:, i] == 1).sum()] for i in range(n)]) / repetitions  
    hamiltonian = np.sum(Jz * (p[:, 0] - p[:, 1]))  
    for i in range(n):  
        for j in range(i + 1, n):  
            hamiltonian += Uzz[i, j] * (p[i, 0] * p[j, 0] - p[i, 0] * p[j, 1] -  
                                        p[i, 1] * p[j, 0] + p[i, 1] * p[j, 1])  
    return hamiltonian  
  

# среднее значение гамильтониана рассчитанное с помощью simulate()
def find_mean_hamiltonian_simulate(n, teta, hamiltonian, depth):  
    circuit = cirq.Circuit()  
    circuit.append(Anzatz(n, teta, depth))  
    res = cirq.Simulator().simulate(circuit).state_vector().reshape((-1, 1))  
    return (np.conj(res.T) @ hamiltonian @ res).real[0, 0]  
  
  
def find_state(n, teta, depth):  
    circuit = cirq.Circuit()  
    circuit.append(Anzatz(n, teta, depth, measurment_gates=True))  
    res = cirq.Simulator().run(circuit).data.to_numpy()[0]  
    return res  
  
  
def exact_solution(Uzz, Jz):  
    n = Jz.shape[0]  
  
    def kron(l):  
        if len(l) > 1:  
            res = l[:-2] + [np.kron(l[-2], l[-1])]  
            return kron(res)  
        elif len(l) == 1:  
            return l[0]  
  
    def mask(n, x):  
        res = np.zeros(n)  
        res[x] = 1  
        return res  
  
    def mask2matrix(mask, matrix):  
        return [matrix if i == 1 else np.eye(2) for i in mask]  
  
    def sumL(l):  
        res = []  
        for i in range(len(l)):  
            res += l[i]  
        return res  
  
    m2mZ = partial(mask2matrix, matrix=np.array([[1, 0], [0, -1]]))  
  
    def fz(x):  
        return kron(m2mZ(mask(n, x)))  
  
    hamiltonianZZ = [[Uzz[i, j] * fz([i, j]) for j in range(i + 1, n)] for i in range(n)]  
    hamiltonianZZ = np.sum(np.array(sumL(hamiltonianZZ)), axis=0)  
    hamiltonianZ = np.sum(np.array([Jz[i] * fz(i) for i in range(n)]), axis=0)  
    hamiltonian = hamiltonianZZ + hamiltonianZ  
  
    binary = bin(int(np.where(hamiltonian == np.min(hamiltonian))[0][0]))[2:]  
    binary = (n - len(binary)) * "0" + binary  
    state = np.array(list(map(int, list(binary))))  
    return np.min(np.linalg.eigvalsh(hamiltonian)), state, hamiltonian  
  
  
n = 3  
depth = 2  
  
Uzz = np.random.random((n, n))  
Jz = np.random.random(n)  
  
ex_energy, ex_state, hamiltonian = exact_solution(Uzz, Jz)  
print(f"Точная минимальная энергия: {ex_energy}")  
print(f"Точное состояние с минимальной энергией: {ex_state}", end="\n\n")  
  
teta1 = np.zeros(2 * n * depth)  
teta2 = np.zeros(2 * n * depth)  
energy_run = partial(find_mean_hamiltonian_run, n, Uzz=Uzz, Jz=Jz, depth=depth, repetitions=1000)  
energy_sim = partial(find_mean_hamiltonian_simulate, n, hamiltonian=hamiltonian, depth=depth)  
  
time1 = time.time()  
teta1 = minimize(energy_run, teta1, method="Powell", tol=1e-3).x  
time1 = np.round(time.time() - time1, 2)  
  
time2 = time.time()  
teta2 = minimize(energy_sim, teta2, method="Powell", tol=1e-3).x  
time2 = np.round(time.time() - time2, 2)  
  
print(f"Рассчитанная энергия c помощью run(): {energy_run(teta1)}")  
print(f"Рассчитанная энергия c помощью run(): {energy_run(teta1)}")  
print(f"Рассчитанное состояние с помощью run(): {find_state(n, teta1, depth)}")  
print(f"Время оптимизации - {time1} сек", end="\n\n")  
  
print(f"Рассчитанная энергия c помощью simulate(): {energy_sim(teta2)}")  
print(f"Рассчитанная энергия c помощью simulate(): {energy_sim(teta2)}")  
print(f"Рассчитанное состояние с помощью simulate(): {find_state(n, teta2, depth)}")  
print(f"Время оптимизации - {time2} сек")
```
###### Реализация QUBO-модели и модели Изинга на примере задачи рюкзака

Была реализована генерация задачи рюкзака, а затем по ней составлены QUBO-матрица и нужная модель Изинга.

В первом приближении работоспособность проверялась следующим образом: 
- Для QUBO модели составлялись все возможные вектора путем бинаризации всех чисел в диапазоне $[0, 2^n - 1]$, а затем методом перебора находилось наименьшее значение
- Для модели Изинга также составлялись бинаризации всех чисел в  $[0, 2^n - 1]$, а затем 0 отовсюду заменялись на -1. Решение также находилось перебором.

Далее собиралась статистика правильных/неправильных решений на основе разных моделей рюкзака одинаковой длины. Было получено:

- Для n = 6:
	
	![[Pasted image 20241226150347.png]]

- Для n = 10:
	
	![[Pasted image 20241226150739.png]]

- Для n = 12:
	![[Pasted image 20241226151250.png]]

В целом, было показано, что решения исходной задачи в формулировке модели Изинга и в формулировке QUBO-модели дают результат, совпадающий с точным результатом для задач разных размерностей, что означает, что модели составлены правильно, и их можно использовать для дальнейших исследований.

###### Решение задачи рюкзака c помощью VQE.

Так как были получены верные формулировки модели Изинга для задачи рюкзака, то данную модель можно использовать для ее решения на базе алгоритма VQE.

Для универсального класса решателя VQE необходимы следующие вводные:

- $U_{zz}$ - матрица перекрестных значений взаимодействий кубит
- $J_z$ - вектор значений влияний поперечного магнитного поля на кубиты
- $J_x$ - вектор значений влияний продольного магнитного поля на кубиты

Для формулировки задачи рюкзака необходимы только $U_{zz}$ и $J_z$ , $J_x$ принимается нулевым.
Была произведена генерация следующей задачи:
![[Pasted image 20241226155618.png]]
По ней создалась нужная модель Изинга:
![[Pasted image 20241226155646.png]]

Точное решение, а также вводные для VQE-решателя были сохранены, а затем велась работа с другой программой, которая непосредственно занималась решением нужной проблемы:

В данную программу была загружена данная модель (без сбоев).

После проведение экспериментов с разной глубиной цепи было несколько раз получено правильное решение, но актуальной проблемой все еще остается алгоритм оптимизации, так как используемый на данном этапе метод оптимизации не дает строго верного результата, а на больших выбранных глубинах цепи - не сходится к правильному ответу.

Первый прогон:
![[Pasted image 20241226161715.png]]

Второй прогон:
![[Pasted image 20241226161748.png]]

Третий прогон:
![[Pasted image 20241226162020.png]]

$\int$